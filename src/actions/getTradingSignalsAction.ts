import type { Action } from "@elizaos/core";
import {
    validateTokenMetricsParams,
    callTokenMetricsApi,
    buildTokenMetricsParams,
    formatTokenMetricsResponse,
    extractTokenIdentifier,
    formatTokenMetricsNumber,
    TOKENMETRICS_ENDPOINTS
} from "./action";
import type { TradingSignalsResponse, TradingSignalsRequest } from "../types";

/**
 * Action to get AI-generated trading signals from TokenMetrics.
 * This action provides comprehensive long and short position signals
 * generated by TokenMetrics' AI algorithms for all supported tokens.
 * 
 * Real Endpoint: GET https://api.tokenmetrics.com/v2/trading-signals
 * 
 * The trading signals include:
 * - SIGNAL_TYPE: Long or Short position recommendations
 * - AI_CONFIDENCE: Confidence level of the AI-generated signal
 * - ENTRY_PRICE: Recommended entry price for the position
 * - TARGET_PRICE: Price target for the position
 * - STOP_LOSS: Risk management stop-loss price
 * - SIGNAL_STRENGTH: Overall strength of the trading signal
 * 
 * These signals are generated using TokenMetrics' proprietary AI models
 * that analyze multiple data sources including technical indicators,
 * on-chain metrics, and market sentiment to provide actionable trading recommendations.
 */
export const getTradingSignalsAction: Action = {
    name: "getTradingSignals",
    description: "Get AI-generated trading signals for long and short positions from TokenMetrics with entry points and risk management levels",
    similes: [
        "get trading signals",
        "get AI signals",
        "check buy sell signals",
        "get trading recommendations",
        "AI trading signals",
        "long short signals",
        "get entry exit points",
        "trading opportunities"
    ],
    
    async handler(_runtime, message, _state) {
        try {
            // Extract parameters from the message content
            const messageContent = message.content as any;
            
            // Extract token identifiers from the user's request
            const tokenIdentifier = extractTokenIdentifier(messageContent);
            
            // Build request parameters for the real TokenMetrics trading-signals endpoint
            const requestParams: TradingSignalsRequest = {
                // Token identification - use either token_id or symbol
                token_id: tokenIdentifier.token_id,
                symbol: tokenIdentifier.symbol,
                
                // Signal type filter - long, short, or all
                signal_type: typeof messageContent.signal_type === 'string' ? 
                    messageContent.signal_type as 'long' | 'short' | 'all' : 'all',
                
                // Date range parameters for historical signal analysis
                start_date: typeof messageContent.start_date === 'string' ? messageContent.start_date : undefined,
                end_date: typeof messageContent.end_date === 'string' ? messageContent.end_date : undefined,
                
                // Pagination for large datasets
                limit: typeof messageContent.limit === 'number' ? messageContent.limit : undefined,
            };
            
            // Validate all parameters according to TokenMetrics API requirements
            validateTokenMetricsParams(requestParams);
            
            // Build clean parameters for the API request
            const apiParams = buildTokenMetricsParams(requestParams);
            
            console.log("Fetching trading signals from TokenMetrics v2/trading-signals endpoint");
            
            // Make the API call to the real TokenMetrics trading-signals endpoint
            const response = await callTokenMetricsApi<TradingSignalsResponse>(
                TOKENMETRICS_ENDPOINTS.tradingSignals,
                apiParams,
                "GET"
            );
            
            // Format the response data for consistent structure
            const formattedData = formatTokenMetricsResponse<TradingSignalsResponse>(response, "getTradingSignals");
            
            // Process the real API response structure
            const tradingSignals = Array.isArray(formattedData) ? formattedData : formattedData.data || [];
            
            // Analyze the trading signals to provide actionable insights
            const signalsAnalysis = analyzeTradingSignals(tradingSignals);
            
            // Return comprehensive trading signals analysis with actionable insights
            return {
                success: true,
                message: `Successfully retrieved ${tradingSignals.length} trading signals from TokenMetrics AI`,
                trading_signals: tradingSignals,
                analysis: signalsAnalysis,
                // Include metadata about the request
                metadata: {
                    endpoint: TOKENMETRICS_ENDPOINTS.tradingSignals,
                    requested_token: tokenIdentifier.symbol || tokenIdentifier.token_id,
                    signal_type_filter: requestParams.signal_type,
                    date_range: {
                        start: requestParams.start_date,
                        end: requestParams.end_date
                    },
                    data_points: tradingSignals.length,
                    api_version: "v2",
                    data_source: "TokenMetrics AI Signals"
                },
                // Provide educational context about TokenMetrics trading signals
                signals_explanation: {
                    SIGNAL_TYPE: {
                        LONG: "AI recommends buying/holding position - expects price to rise",
                        SHORT: "AI recommends short position - expects price to fall"
                    },
                    AI_CONFIDENCE: "Confidence level of the AI model in the signal (0-100%)",
                    ENTRY_PRICE: "Recommended price level to enter the position",
                    TARGET_PRICE: "Price target where profits should be taken",
                    STOP_LOSS: "Risk management level to limit losses",
                    usage_guidelines: [
                        "Higher AI confidence signals are typically more reliable",
                        "Always use stop-loss levels for risk management",
                        "Consider position sizing based on signal strength and confidence",
                        "Monitor for signal updates as market conditions change"
                    ]
                }
            };
            
        } catch (error) {
            console.error("Error in getTradingSignalsAction:", error);
            
            // Return detailed error information with troubleshooting guidance
            return {
                success: false,
                error: error instanceof Error ? error.message : "Unknown error occurred while fetching trading signals",
                message: "Failed to retrieve trading signals from TokenMetrics API",
                // Include helpful troubleshooting steps for the real endpoint
                troubleshooting: {
                    endpoint_verification: "Ensure https://api.tokenmetrics.com/v2/trading-signals is accessible",
                    parameter_validation: [
                        "Verify the token symbol or ID is correct and supported by TokenMetrics",
                        "Check that signal_type is 'long', 'short', or 'all'",
                        "Ensure date ranges are in YYYY-MM-DD format",
                        "Confirm your API key has access to trading signals endpoint"
                    ],
                    common_solutions: [
                        "Try using signal_type='all' to get both long and short signals",
                        "Use a major token (BTC, ETH) to test functionality",
                        "Check if your subscription includes AI trading signals",
                        "Verify the token has active signals available"
                    ]
                }
            };
        }
    },
    
    /**
     * Validate that the runtime environment supports trading signals access.
     * Trading signals may require premium subscription levels.
     */
    validate: async (runtime, _message) => {
        const apiKey = runtime.getSetting("TOKENMETRICS_API_KEY");
        if (!apiKey) {
            console.warn("TokenMetrics API key not found. Please set TOKENMETRICS_API_KEY environment variable.");
            return false;
        }
        return true;
    },
    
    /**
     * Examples showing different ways to use the trading signals endpoint.
     * These examples reflect real TokenMetrics API usage patterns.
     */
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Get me AI trading signals for Bitcoin",
                    symbol: "BTC"
                }
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll retrieve the latest AI-generated trading signals for Bitcoin from TokenMetrics.",
                    action: "GET_TRADING_SIGNALS"
                }
            }
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Show me long signals for Ethereum",
                    symbol: "ETH",
                    signal_type: "long"
                }
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll get the long position signals for Ethereum from TokenMetrics AI.",
                    action: "GET_TRADING_SIGNALS"
                }
            }
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "What are the current trading opportunities with high AI confidence?"
                }
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll fetch the latest trading signals and highlight those with high AI confidence scores.",
                    action: "GET_TRADING_SIGNALS"
                }
            }
        ]
    ],
};

/**
 * Comprehensive analysis function for trading signals from TokenMetrics.
 * This function processes real API response data and provides actionable trading insights.
 * 
 * @param signalsData - Array of trading signals data from TokenMetrics API
 * @returns Analysis with trading opportunities and risk assessment
 */
function analyzeTradingSignals(signalsData: any[]): any {
    if (!signalsData || signalsData.length === 0) {
        return {
            summary: "No trading signals available for analysis",
            active_opportunities: 0,
            signal_quality: "Unknown",
            recommendations: []
        };
    }
    
    // Analyze signal distribution and quality
    const signalDistribution = analyzeSignalDistribution(signalsData);
    const signalQuality = assessSignalQuality(signalsData);
    const opportunityAnalysis = identifyBestOpportunities(signalsData);
    const riskAssessment = assessSignalRisks(signalsData);
    
    return {
        summary: `TokenMetrics AI analysis shows ${signalsData.length} signals with ${signalQuality.average_confidence}% average confidence`,
        
        signal_distribution: signalDistribution,
        
        signal_quality_assessment: signalQuality,
        
        top_opportunities: opportunityAnalysis.top_signals,
        
        risk_assessment: riskAssessment,
        
        actionable_insights: generateSignalInsights(signalsData, signalQuality, opportunityAnalysis),
        
        recommendations: generateTradingRecommendations(signalsData, signalQuality, riskAssessment),
        
        data_quality: {
            source: "TokenMetrics AI Engine",
            total_signals: signalsData.length,
            signal_types: signalDistribution.types_available,
            latest_signal_date: getLatestSignalDate(signalsData),
            reliability: "High - AI-powered analysis"
        }
    };
}

// Helper functions for trading signals analysis

function analyzeSignalDistribution(signalsData: any[]): any {
    const longSignals = signalsData.filter(s => s.SIGNAL_TYPE === 'LONG').length;
    const shortSignals = signalsData.filter(s => s.SIGNAL_TYPE === 'SHORT').length;
    const totalSignals = signalsData.length;
    
    const longPercentage = (longSignals / totalSignals) * 100;
    const shortPercentage = (shortSignals / totalSignals) * 100;
    
    let marketBias;
    if (longPercentage > 70) marketBias = "Strongly Bullish";
    else if (longPercentage > 55) marketBias = "Bullish";
    else if (longPercentage > 45) marketBias = "Neutral";
    else if (longPercentage > 30) marketBias = "Bearish";
    else marketBias = "Strongly Bearish";
    
    return {
        long_signals: longSignals,
        short_signals: shortSignals,
        long_percentage: longPercentage.toFixed(1),
        short_percentage: shortPercentage.toFixed(1),
        market_bias: marketBias,
        types_available: [
            ...(longSignals > 0 ? ['LONG'] : []),
            ...(shortSignals > 0 ? ['SHORT'] : [])
        ]
    };
}

function assessSignalQuality(signalsData: any[]): any {
    // Calculate average confidence
    const confidenceScores = signalsData
        .map(s => s.AI_CONFIDENCE)
        .filter(c => c !== null && c !== undefined);
    
    const avgConfidence = confidenceScores.length > 0 ? 
        confidenceScores.reduce((sum, c) => sum + c, 0) / confidenceScores.length : 0;
    
    // Count high-confidence signals
    const highConfidenceSignals = signalsData.filter(s => s.AI_CONFIDENCE >= 80).length;
    const mediumConfidenceSignals = signalsData.filter(s => s.AI_CONFIDENCE >= 60 && s.AI_CONFIDENCE < 80).length;
    const lowConfidenceSignals = signalsData.filter(s => s.AI_CONFIDENCE < 60).length;
    
    // Assess signal freshness
    const recentSignals = signalsData.filter(s => {
        const signalDate = new Date(s.DATE);
        const threeDaysAgo = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
        return signalDate > threeDaysAgo;
    }).length;
    
    let qualityRating;
    if (avgConfidence >= 80) qualityRating = "Excellent";
    else if (avgConfidence >= 70) qualityRating = "Good";
    else if (avgConfidence >= 60) qualityRating = "Fair";
    else qualityRating = "Poor";
    
    return {
        average_confidence: avgConfidence.toFixed(1),
        quality_rating: qualityRating,
        high_confidence_count: highConfidenceSignals,
        medium_confidence_count: mediumConfidenceSignals,
        low_confidence_count: lowConfidenceSignals,
        recent_signals_count: recentSignals,
        confidence_distribution: {
            high: `${((highConfidenceSignals / signalsData.length) * 100).toFixed(1)}%`,
            medium: `${((mediumConfidenceSignals / signalsData.length) * 100).toFixed(1)}%`,
            low: `${((lowConfidenceSignals / signalsData.length) * 100).toFixed(1)}%`
        }
    };
}

function identifyBestOpportunities(signalsData: any[]): any {
    // Sort by AI confidence and filter for high-quality signals
    const highQualitySignals = signalsData
        .filter(s => s.AI_CONFIDENCE >= 70 && s.ENTRY_PRICE && s.TARGET_PRICE)
        .sort((a, b) => b.AI_CONFIDENCE - a.AI_CONFIDENCE)
        .slice(0, 5); // Top 5 opportunities
    
    const opportunities = highQualitySignals.map(signal => {
        const potentialReturn = calculatePotentialReturn(signal);
        const riskRewardRatio = calculateRiskRewardRatio(signal);
        
        return {
            token: `${signal.NAME} (${signal.SYMBOL})`,
            signal_type: signal.SIGNAL_TYPE,
            ai_confidence: `${signal.AI_CONFIDENCE}%`,
            entry_price: formatTokenMetricsNumber(signal.ENTRY_PRICE, 'currency'),
            target_price: formatTokenMetricsNumber(signal.TARGET_PRICE, 'currency'),
            stop_loss: signal.STOP_LOSS ? formatTokenMetricsNumber(signal.STOP_LOSS, 'currency') : 'N/A',
            potential_return: `${potentialReturn.toFixed(1)}%`,
            risk_reward_ratio: riskRewardRatio.toFixed(2),
            signal_date: signal.DATE,
            overall_score: calculateOpportunityScore(signal, potentialReturn, riskRewardRatio)
        };
    });
    
    return {
        top_signals: opportunities,
        total_high_quality: highQualitySignals.length,
        average_confidence: highQualitySignals.length > 0 ? 
            (highQualitySignals.reduce((sum, s) => sum + s.AI_CONFIDENCE, 0) / highQualitySignals.length).toFixed(1) : '0'
    };
}

function assessSignalRisks(signalsData: any[]): any {
    const risks = [];
    
    // Check for concentrated exposure
    const tokenCounts: { [key: string]: number } = {};
    signalsData.forEach(signal => {
        tokenCounts[signal.SYMBOL] = (tokenCounts[signal.SYMBOL] || 0) + 1;
    });
    
    const maxTokenExposure = Math.max(...Object.values(tokenCounts) as number[]);
    if (maxTokenExposure > signalsData.length * 0.3) {
        risks.push("High concentration in single token - diversification recommended");
    }
    
    // Check for signal vintage
    const oldSignals = signalsData.filter(s => {
        const signalDate = new Date(s.DATE);
        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        return signalDate < weekAgo;
    }).length;
    
    if (oldSignals > signalsData.length * 0.5) {
        risks.push("Many signals are over a week old - effectiveness may be reduced");
    }
    
    // Check for missing risk management data
    const signalsWithoutStopLoss = signalsData.filter(s => !s.STOP_LOSS).length;
    if (signalsWithoutStopLoss > 0) {
        risks.push(`${signalsWithoutStopLoss} signals lack stop-loss levels - manual risk management required`);
    }
    
    return {
        risk_factors: risks.length > 0 ? risks : ["No significant risk factors identified"],
        risk_level: risks.length > 2 ? "High" : risks.length > 0 ? "Moderate" : "Low",
        risk_mitigation_suggestions: [
            "Diversify across multiple tokens and signal types",
            "Use proper position sizing based on confidence levels",
            "Always implement stop-loss orders for risk management",
            "Monitor signals regularly for updates and changes"
        ]
    };
}

function generateSignalInsights(signalsData: any[], signalQuality: any, opportunityAnalysis: any): string[] {
    const insights = [];
    
    // Quality-based insights
    if (parseFloat(signalQuality.average_confidence) >= 80) {
        insights.push("High average AI confidence suggests strong signal reliability from TokenMetrics.");
    } else if (parseFloat(signalQuality.average_confidence) < 60) {
        insights.push("Lower AI confidence levels suggest exercising extra caution with signal execution.");
    }
    
    // Opportunity insights
    if (opportunityAnalysis.top_signals.length >= 3) {
        insights.push(`${opportunityAnalysis.top_signals.length} high-quality trading opportunities identified.`);
    } else if (opportunityAnalysis.top_signals.length === 0) {
        insights.push("No high-confidence trading opportunities currently available.");
    }
    
    // Distribution insights
    const longSignals = signalsData.filter(s => s.SIGNAL_TYPE === 'LONG').length;
    const shortSignals = signalsData.filter(s => s.SIGNAL_TYPE === 'SHORT').length;
    
    if (longSignals > shortSignals * 2) {
        insights.push("TokenMetrics AI shows strong bullish bias across analyzed tokens.");
    } else if (shortSignals > longSignals * 2) {
        insights.push("TokenMetrics AI shows bearish bias - consider defensive positioning.");
    }
    
    return insights;
}

function generateTradingRecommendations(signalsData: any[], signalQuality: any, riskAssessment: any): string[] {
    const recommendations = [];
    
    // Quality-based recommendations
    if (parseFloat(signalQuality.average_confidence) >= 75) {
        recommendations.push("High signal quality supports active trading with appropriate position sizing");
    } else {
        recommendations.push("Moderate signal quality suggests conservative position sizing and extra due diligence");
    }
    
    // Risk-based recommendations
    if (riskAssessment.risk_level === "High") {
        recommendations.push("High risk level detected - use smaller positions and strict risk management");
    }
    
    // General trading recommendations
    recommendations.push("Focus on signals with AI confidence above 70% for better success probability");
    recommendations.push("Always use stop-loss orders as specified in TokenMetrics signals");
    recommendations.push("Monitor signal updates regularly as market conditions change");
    recommendations.push("Diversify across multiple signals to reduce concentration risk");
    
    return recommendations;
}

// Utility functions for signal analysis

function calculatePotentialReturn(signal: any): number {
    if (!signal.ENTRY_PRICE || !signal.TARGET_PRICE) return 0;
    
    if (signal.SIGNAL_TYPE === 'LONG') {
        return ((signal.TARGET_PRICE - signal.ENTRY_PRICE) / signal.ENTRY_PRICE) * 100;
    } else {
        return ((signal.ENTRY_PRICE - signal.TARGET_PRICE) / signal.ENTRY_PRICE) * 100;
    }
}

function calculateRiskRewardRatio(signal: any): number {
    if (!signal.ENTRY_PRICE || !signal.TARGET_PRICE || !signal.STOP_LOSS) return 0;
    
    const reward = Math.abs(signal.TARGET_PRICE - signal.ENTRY_PRICE);
    const risk = Math.abs(signal.ENTRY_PRICE - signal.STOP_LOSS);
    
    return risk > 0 ? reward / risk : 0;
}

function calculateOpportunityScore(signal: any, potentialReturn: number, riskRewardRatio: number): number {
    let score = 0;
    
    // Confidence component (40% weight)
    score += (signal.AI_CONFIDENCE / 100) * 40;
    
    // Risk-reward component (30% weight)
    score += Math.min(riskRewardRatio / 3, 1) * 30;
    
    // Potential return component (30% weight)
    score += Math.min(Math.abs(potentialReturn) / 20, 1) * 30;
    
    return Math.round(score);
}

function getLatestSignalDate(signalsData: any[]): string {
    if (signalsData.length === 0) return 'N/A';
    
    const sortedByDate = signalsData
        .filter(s => s.DATE)
        .sort((a, b) => new Date(b.DATE).getTime() - new Date(a.DATE).getTime());
    
    return sortedByDate.length > 0 ? sortedByDate[0].DATE : 'N/A';
}